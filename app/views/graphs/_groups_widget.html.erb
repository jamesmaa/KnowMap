<% if @graph %><%= render :partial => 'groups_widget_button', :locals => { :g => @graph } %><% end %>
<script>
  var btnDefaultColor = d3.select(".group-button").select("rect").style("fill");
  var usedColor = [];
  var unUsedColor = MAP_CONSTANTS.highlight_colors;
  var nodeColors = {};

  d3.selectAll(".group-button").on("click",groupClick);

  function groupClick() {
    var btn = d3.select(this);
    var btnRect = btn.select("rect");

    var ids = $.parseJSON(btn.attr("data-nodes"));

    var nodesToColor = d3.select("#chart-group").selectAll(".node")
      .filter(function(d) { return ids.indexOf(d.id) > -1 } );

    if ((btnRect.style("fill") == btnDefaultColor) && (unUsedColor.length > 0)) {
      $.ajax("/log/graph/"+this.id+"/highlight"); // log action
      var color = unUsedColor.shift();

      btnRect.style("fill",color);
      color = btnRect.style("fill");
      usedColor.push(color);

      nodesToColor.each(function(d) {
        if (nodeColors[d.id] == undefined)
          nodeColors[d.id] = [];

        nodeColors[d.id].push(color);

        addCircleParts(d3.select(this).select("#g-group"),
          nodeColors[d.id]);
      });
    } else if (btnRect.style("fill") != btnDefaultColor) {
      $.ajax("/log/graph/"+this.id+"/unhighlight"); // log action
      var color = btnRect.style("fill");
      unUsedColor.push(color);
      usedColor.splice(usedColor.indexOf(color),1);

      btnRect.style("fill",btnDefaultColor);
      nodesToColor.each(function(d) {
        var aryColors = nodeColors[d.id];
        nodeColors[d.id] = [];

        for (c in aryColors) {
          if (aryColors[c] != color)
            nodeColors[d.id].push(aryColors[c]);
        }

        addCircleParts(d3.select(this).select("#g-group"),
          nodeColors[d.id]);
      });
    }
  }

  function addCircleParts(svgG,colors) {
    var colorR = MAP_CONSTANTS.highlight_radius;
    var rotateRadian = Math.PI/2;
  
    svgG.selectAll("path.cParts").remove();
    svgG.selectAll("circle.cParts").remove();
  
    if (colors.length == 1) { // If one color just want a circle
      svgG.selectAll("circle.cParts").data(colors).enter().append("circle")
        .attr("class","cParts")
        .attr("fill",function(d){return d;})
        .style("opacity",MAP_CONSTANTS.highlight_opacity)
        .attr("r",colorR);
    } else {
      svgG.selectAll("path.cParts").data(colors).enter().append("path")
       .attr("class","cParts")
       .attr("fill",function(d){return d;})
       .style("opacity",MAP_CONSTANTS.highlight_opacity)
       .attr("d",function(d){
         var outStr = "M0,0 "; //Center

         var i = colors.indexOf(d);
         var len = colors.length;

         // Have -0.001 so there is a very slight overlap of the circle parts
         var x1 = colorR*Math.cos(Math.PI*2*((i/len)-0.001) - rotateRadian);
         var y1 = colorR*Math.sin(Math.PI*2*((i/len)-0.001) - rotateRadian);
  
         outStr += "L"+x1+","+y1+" ";
  
         var x2 = colorR*Math.cos(Math.PI*2*((i+1)/len) - rotateRadian);
         var y2 = colorR*Math.sin(Math.PI*2*((i+1)/len) - rotateRadian);
  
         outStr += "A"+colorR+","+colorR+" 0 0,1 ";
         outStr += x2+","+y2+" Z";

         return outStr;
       });
    }
  }
</script>
