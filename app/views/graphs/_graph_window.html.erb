<div id="window">
  <div id="chart" style="height:100%; width:100%;"></div>
  <div class="clear"></div>
</div>

<script type="text/javascript">

  function learningPathNodeX(pos) {
    var spacer = MAP_CONSTANTS.lp_node_radius*1.5;

    return x = spacer + MAP_CONSTANTS.lp_node_radius
                 + pos*(MAP_CONSTANTS.lp_node_radius*2+spacer);
  }

  // Called when a node is clicked on.
  // Currently written like it is a d3 event function.
  function showLearningPath() {
    var lpHeight = parseInt(d3.select("#learning-path-widget-content")
                   .style("height"));
    var nodeY = lpHeight/2;

    var svg = d3.select("#learning-path-svg");
    svg.selectAll("g").remove();

    var id = d3.select(this).attr("id");

    var urlJson = "../nodes/"+id+"/learning_path.json";
    console.log("showLearningPath: "+urlJson);

    d3.json(urlJson, function(json) {
      if (json == null)
        return;

      var lpNodes = json.nodes;
      var lpLinks = [];
      var lpNodesMap = {};

      //Get aryLabel for the lpNodes from nodes.
      for (n in lpNodes) {
        lpNodes[n].aryLabel = nodeMap[lpNodes[n].id].aryLabel;
        lpNodes[n].pos = n;

        lpNodesMap[lpNodes[n].id] = lpNodes[n];
      }

      //Filter to only edges that are dependent edges.
      var maxPosDiff = 0;
      var minPosDiff = 0;
      for (l in json.lines) {
        if (json.lines[l].type == "DependentEdge")
          lpLinks.push(json.lines[l]);


        var nodeS = lpNodesMap[json.lines[l].source]
        var nodeT = lpNodesMap[json.lines[l].target]

        var diff = nodeT.pos - nodeS.pos;
        if (diff > maxPosDiff)
          maxPosDiff = diff;
        if (diff < minPosDiff)
          minPosDiff = diff;
      }

      var svgLinkGroup = svg.append("g");
      var svgMarkerDef = svgLinkGroup.append("defs");
      var svgNodeGroup = svg.append("g");

      //Add arrowhead markers
      for (i=0; i<(maxPosDiff-minPosDiff+1); i++) {
        if (i == 0)
          continue;
        var angle = 15;
        var mult = minPosDiff + i;
        if (mult < 0) {
          angle = 180;
          mult *= -1;
        }
        svgMarkerDef.append("marker")
          .attr("class", "lp-arrowhead")
          .attr("id", "arrowhead-"+(minPosDiff+i))
          .attr("viewBox", "0 0 10 10")
          .attr("refX", 10)
          .attr("refY", 5)
          .attr("markerUnits", "strokeWidth")
          .attr("markerWidth", 5)
          .attr("markerHeight", 5)
          .style("hover:fill","red")
          .attr("orient", angle+45*(mult/4.5))
          .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 Z");
      }

      //Add Edges
      var link = svgLinkGroup.selectAll("line.link")
          .data(lpLinks)
        .enter().append("path")
          .attr("class","lp-link")
          .attr("d",function(d){
            var nodeSource = lpNodesMap[d.source];
            var nodeTarget = lpNodesMap[d.target];

            var rCircle = MAP_CONSTANTS.lp_node_radius;

            var x1 = learningPathNodeX(nodeSource.pos);
            var x2 = learningPathNodeX(nodeTarget.pos);

            var y1 = y2 = nodeY - MAP_CONSTANTS.lp_node_radius;

            var rX = (x2-x1)/2.0;
            var rY = (nodeTarget.pos-nodeSource.pos)*rCircle/4.0;

            if (d.target < d.source) {
              rX *= -1;
              rY *= -1;
              y1 += rCircle*2;
              y2 += rCircle*2;
            }

            var pathStr = "M"+x1+","+y1+" ";
            pathStr += "A"+rX+","+rY+" 0 0,1 "+x2+","+y2;

            return pathStr;
          })
          .style("fill","none")
          .style("marker-end", function(d){
            var nodeSource = lpNodesMap[d.source];
            var nodeTarget = lpNodesMap[d.target];
            var diff = nodeTarget.pos - nodeSource.pos;
            return "url(#arrowhead-"+diff+")";
          });

      //Add nodes
      var nodeGNode = svgNodeGroup.selectAll("g.node")
          .data(lpNodes)
        .enter().append("g")
          .attr("class","node")
          .attr("id",function(d){return d.id;})
          .attr("transform",function(d){
             return "translate("+learningPathNodeX(d.pos)+","+nodeY+")";
          });

      nodeGNode.append("circle")
       .attr("class", "map-node")
       .attr("r", MAP_CONSTANTS.lp_node_radius);

      nodeGNode.append("g")
        .attr("id","g-node-label")
        .each(function(d) {
          var g = d3.select(this);
          var startDY = 0.5 - (d.aryLabel.length/2.0);
          startDY += MAP_CONSTANTS.node_text_dy;
          for(i in d.aryLabel) {
            g.append("text").text(d.aryLabel[i])
              .attr("class","lp-node-text")
              .attr("dy",(startDY+parseInt(i))+"em");
          }
        });
      nodeGNode.append("title")
        .attr("data-id", function(d){return d.id;})
          .text(function(d){return d.title;});

    });
  }
</script>
